import { EthSecp256k1HDWallet } from '../ethSecp256k1hd';
import { HDPath } from '@interchainjs/types';
import { Secp256k1HDWallet as CosmosSecp256k1HDWallet } from '@interchainjs/cosmos/wallets/secp256k1hd';

// Test mnemonic for consistent testing
const TEST_MNEMONIC = 'abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon abandon art';

// Expected addresses for validation (deterministic from test mnemonic)
// These are the actual addresses generated by the Ethereum-style derivation
const EXPECTED_ADDRESSES = {
  injective: {
    path0: 'inj1tc2a46eulpthxhr2etjcwqlsfa78h4w0z77gx5', // m/44'/118'/0'/0/0
    path1: 'inj1wnk8qn4ad6kevekdym5lwxh0skjg5uupnpqe9v', // m/44'/118'/0'/0/1
    path2: 'inj1xjz3j4g6dtsg0z5xeqr730hhkjss0mgt8epwlm'  // m/44'/118'/0'/0/2
  }
};

describe('EthSecp256k1HDWallet', () => {
  let wallet: EthSecp256k1HDWallet;

  describe('fromMnemonic', () => {
    it('should create wallet from valid mnemonic with single HD path', async () => {
      const hdPath = HDPath.cosmos(0, 0, 0);
      wallet = await EthSecp256k1HDWallet.fromMnemonic(TEST_MNEMONIC, { derivations: [{ hdPath: hdPath.toString(), prefix: 'inj' }] });

      expect(wallet).toBeInstanceOf(EthSecp256k1HDWallet);
      const accounts = await wallet.getAccounts();
      expect(accounts).toHaveLength(1);

      // Verify the expected address
      expect(accounts[0].address).toBe(EXPECTED_ADDRESSES.injective.path0);
      expect(accounts[0].address).toMatch(/^inj1[a-z0-9]{38}$/);
      expect(accounts[0].algo).toBe('secp256k1');

      // Test AccountData interface (which has pubkey property)
      const accountsData = await wallet.getAccountsData();
      expect(accountsData[0].pubkey).toBeInstanceOf(Uint8Array);

      // Test that we can get public key from IAccount
      const publicKey = accounts[0].getPublicKey();
      expect(publicKey.value.value).toBeInstanceOf(Uint8Array);
    });

    it('should create wallet with multiple HD paths', async () => {
      const hdPaths = [
        HDPath.cosmos(0, 0, 0),
        HDPath.cosmos(0, 0, 1),
        HDPath.cosmos(0, 0, 2)
      ];

      wallet = await EthSecp256k1HDWallet.fromMnemonic(TEST_MNEMONIC, { derivations: hdPaths.map(path => ({ hdPath: path.toString(), prefix: 'inj' })) });

      const accounts = await wallet.getAccounts();
      expect(accounts).toHaveLength(3);

      // Verify the expected addresses
      expect(accounts[0].address).toBe(EXPECTED_ADDRESSES.injective.path0);
      expect(accounts[1].address).toBe(EXPECTED_ADDRESSES.injective.path1);
      expect(accounts[2].address).toBe(EXPECTED_ADDRESSES.injective.path2);

      // Test AccountData interface (which has pubkey property)
      const accountsData = await wallet.getAccountsData();

      // Verify all addresses have correct format
      accounts.forEach((account, index) => {
        expect(account.address).toMatch(/^inj1[a-z0-9]{38}$/);
        expect(account.algo).toBe('secp256k1');
        expect(accountsData[index].pubkey).toBeInstanceOf(Uint8Array);
      });
    });

    it('should reject invalid mnemonic', async () => {
      await expect(
        EthSecp256k1HDWallet.fromMnemonic('invalid mnemonic phrase')
      ).rejects.toThrow('Invalid mnemonic');
    });

    it('should create wallet with custom prefix', async () => {
      const hdPath = HDPath.cosmos(0, 0, 0);
      wallet = await EthSecp256k1HDWallet.fromMnemonic(TEST_MNEMONIC, {
        derivations: [{ hdPath: hdPath.toString(), prefix: 'inj' }]
      });

      const accounts = await wallet.getAccounts();
      expect(accounts[0].address).toMatch(/^inj1[a-z0-9]{38}$/);
    });
  });

  describe('getAccountByIndex', () => {
    beforeEach(async () => {
      const hdPaths = [
        HDPath.cosmos(0, 0, 0),
        HDPath.cosmos(0, 0, 1),
        HDPath.cosmos(0, 0, 2)
      ];
      wallet = await EthSecp256k1HDWallet.fromMnemonic(TEST_MNEMONIC, { derivations: hdPaths.map(path => ({ hdPath: path.toString(), prefix: 'inj' })) });
    });

    it('should get account by valid index', async () => {
      const account0 = await wallet.getAccountByIndex(0);
      const account1 = await wallet.getAccountByIndex(1);

      expect(account0.address).toMatch(/^inj1[a-z0-9]{38}$/);
      expect(account1.address).toMatch(/^inj1[a-z0-9]{38}$/);
      expect(account0.address).not.toBe(account1.address);
    });

    it('should throw error for invalid index', async () => {
      await expect(wallet.getAccountByIndex(10)).rejects.toThrow();
    });
  });

  describe('Address derivation differences', () => {
    it('should generate different addresses than standard Cosmos derivation', async () => {
      // This test verifies that our Ethereum-style derivation produces different addresses
      // than the standard Cosmos derivation would produce
      const hdPath = HDPath.cosmos(0, 0, 0);

      // Create Injective Ethereum-style wallet
      const injectiveWallet = await EthSecp256k1HDWallet.fromMnemonic(TEST_MNEMONIC, {
        derivations: [{ hdPath: hdPath.toString(), prefix: 'inj' }]
      });

      // Create standard Cosmos wallet with same mnemonic and path but inj prefix
      const cosmosWallet = await CosmosSecp256k1HDWallet.fromMnemonic(TEST_MNEMONIC, {
        derivations: [{ hdPath: hdPath.toString(), prefix: 'inj' }]
      });

      const injectiveAccounts = await injectiveWallet.getAccounts();
      const cosmosAccounts = await cosmosWallet.getAccounts();

      const ethStyleAddress = injectiveAccounts[0].address;
      const cosmosStyleAddress = cosmosAccounts[0].address;

      // Verify our Ethereum-style address
      expect(ethStyleAddress).toBe(EXPECTED_ADDRESSES.injective.path0);
      expect(ethStyleAddress).toMatch(/^inj1[a-z0-9]{38}$/);

      // Verify cosmos-style address format
      expect(cosmosStyleAddress).toMatch(/^inj1[a-z0-9]{38}$/);

      // The addresses should be completely different due to different hashing algorithms
      expect(ethStyleAddress).not.toBe(cosmosStyleAddress);

      console.log('Injective Ethereum-style address:', ethStyleAddress);
      console.log('Standard Cosmos-style address:', cosmosStyleAddress);
    });

    it('should use keccak256 hashing for address generation', async () => {
      // This test verifies that the address strategy is using keccak256
      const hdPath = HDPath.cosmos(0, 0, 0);
      wallet = await EthSecp256k1HDWallet.fromMnemonic(TEST_MNEMONIC, {
        derivations: [{ hdPath: hdPath.toString(), prefix: 'inj' }]
      });

      const accounts = await wallet.getAccounts();
      const address = accounts[0].address;

      // The address should be deterministic and match our expected Ethereum-style address
      expect(address).toBe(EXPECTED_ADDRESSES.injective.path0);

      // Verify the address format is correct for Injective
      expect(address).toMatch(/^inj1[a-z0-9]{38}$/);
      expect(address.length).toBe(42); // inj1 + 38 characters
    });
  });

  describe('Signing functionality', () => {
    beforeEach(async () => {
      const hdPath = HDPath.cosmos(0, 0, 0);
      wallet = await EthSecp256k1HDWallet.fromMnemonic(TEST_MNEMONIC, {
        derivations: [{ hdPath: hdPath.toString(), prefix: 'inj' }]
      });
    });

    it('should create offline direct signer', async () => {
      const signer = await wallet.toOfflineDirectSigner();
      const accounts = await signer.getAccounts();

      expect(accounts).toHaveLength(1);
      expect(accounts[0].address).toMatch(/^inj1[a-z0-9]{38}$/);
      expect(typeof signer.signDirect).toBe('function');
    });

    it('should create offline amino signer', async () => {
      const signer = await wallet.toOfflineAminoSigner();
      const accounts = await signer.getAccounts();

      expect(accounts).toHaveLength(1);
      expect(accounts[0].address).toMatch(/^inj1[a-z0-9]{38}$/);
      expect(typeof signer.signAmino).toBe('function');
    });
  });

  describe('HD path testing with helper class', () => {
    it('should correctly use HDPath helper methods', async () => {
      // Test cosmos HD path
      const cosmosPath = HDPath.cosmos(0, 0, 0);
      expect(cosmosPath.toString()).toBe("m/44'/118'/0'/0/0");

      // Test eth HD path
      const ethPath = HDPath.eth(0, 0, 0);
      expect(ethPath.toString()).toBe("m/44'/60'/0'/0/0");

      // Test custom path
      const customPath = new HDPath('123', 5, 1, 10);
      expect(customPath.toString()).toBe("m/44'/123'/5'/1/10");

      // Test from string
      const fromString = HDPath.fromString("m/44'/118'/2'/1/3");
      expect(fromString.coinType).toBe('118');
      expect(fromString.accountIndex).toBe(2);
      expect(fromString.change).toBe(1);
      expect(fromString.addressIndex).toBe(3);
    });

    it('should work with different HD paths', async () => {
      const hdPaths = [
        HDPath.cosmos(0, 0, 0),
        HDPath.cosmos(1, 0, 0),
        HDPath.cosmos(0, 1, 0),
        HDPath.cosmos(0, 0, 1)
      ];

      wallet = await EthSecp256k1HDWallet.fromMnemonic(TEST_MNEMONIC, {
        derivations: hdPaths.map(path => ({ hdPath: path.toString(), prefix: 'inj' }))
      });

      const accounts = await wallet.getAccounts();
      expect(accounts).toHaveLength(4);

      // All addresses should be different
      const addresses = accounts.map(acc => acc.address);
      const uniqueAddresses = new Set(addresses);
      expect(uniqueAddresses.size).toBe(4);

      // All should have correct format
      addresses.forEach(address => {
        expect(address).toMatch(/^inj1[a-z0-9]{38}$/);
      });
    });
  });
});
